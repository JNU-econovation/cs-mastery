# Operating System

### 목차

* [스케줄링](#스케줄링)
* [메모리관리](#메모리관리)
- [페이징(Paging)](#페이징)
  - [메모리 주소 매핑](#메모리-주소-매핑)
    - [1단계 페이징](#1단계-페이징)
    - [계층적 페이징](#계층적-페이징)
- [교착상태](#교착상태)

---

## 스케줄링  
* 시기별 스케줄링 구분
   * 장기 : 프로그램을 프로세스로 만들어주는 것을 결정하는 스케줄링(일괄 처리 시스템의 경우 들어오는 순서대로 디스크에 놓아둔채 장기스케줄러를 거쳐 프로세스가 되도록한다. 시분할 시스템에서는 사용자의 접속시도를 허용하는 과정이다). 작업스케줄링이라고도 한다.
   * 중기 : 보류상태(메모리에서 디스크로 스왑아웃된 상태)의 프로세스들 중 선택하여 준비상태로 바꾸는 스케줄러.
   * **단기** : 준비상태(메모리에 올라온 프로세스)인 프로세스 중 cpu에 할당할 프로세스를 정하는 스케줄러. **디스패처**라고도 한다.
   
   일반적으로 스케줄링은 단기스케줄링을 의미한다. 앞으로의 스케줄링 방법은 단기 스케줄링에 한정된 설명이다.
   
* 연산 위주 혹은 입출력 위주의 프로세스의 성격에 따라 다른 스케줄링 방법이 있다.
* 스케줄링은 선점과 비선점으로 분류할 수 있다.
    * 선점 : cpu가 할당된 상태에서 스케줄러에 의해 다른 프로세스가 cpu를 할당 받을 수 있다.
    * 비선점 : 한번 cpu를 할당받으면 프로세스가 끝날때 까지 선점되지 않는다.
    
* 스케줄링 방식
    * FIFO : 먼저 도착한 프로세스가 먼저 할당 받는 방식
        - 비선점
        - 단순한 장점이 있지만, 응담시간이 느린 등 단점이 많아, 여러 스케줄링 방법의 차선책으로 사용된다.
    * SJF (Shortest Job First) : 작업시간이 작은 프로세스가 먼저 할당 받는 스케줄링 방식이다.
        - 작업시간은 변화가 있기 때문에, 작업시간(프로세스의 크기)를 예측해야 한다는 단점이 있다.
        - 응답시간을 최소화 할 수 있지만, 지속적으로 응답속도가 낮은 프로세스가 도착한다면 응답속도가 긴 프로세스가 처리되지 않을 수도 있다.(기아현상)
        - 기아현상은 특정 시기에 해당 프로세스의 우선순위를 높여주는 **에이징**기법으로 해결 할 수 있다.
    * SRT(Shortest Remaining Time) : SJF 스케줄링에서 비선점을 선점형으로 바꾼 방법이다.
        - 새로운 작업이 큐에 들어오면, 그 순간 남은 작업이 가장 짧은 프로세스를 선택한다.
        - 잦은 문맥교환의 오버헤드가 있다.
    * HRRN(Highest Response Ratio Next) 응답률( (대기사간+cpu처리량)/cpu처리량 )이 높을 수록 우선순위가 낮다.
        - cpu 처리량이 분모에 있기 때문에 처리량이 많을 수록 응답률이 낮아 진다.
        - 대기시간은 분자에 있기 때문에 높을 수록 응답률이 높아진다. 시간이 지남에 따라 우선순위가 올라가게 된다.
    * 라운드로빈 : FIFO를 응용한 방법으로 시간 할당량(Time Quantum) 만큼 먼저들어온 프로세스를 처리한다.
        - 시간 할당량이 10인 경우, p1이 20의 처리량이 필요하다면 10만큼 처리하고 FIFO의 마지막으로 넣는다. 
        - 문백교환 비용이 있다.
        - 응답속도가 빠르기 때문에 대화식 시스템에 적절하다.
        - time Quantum에 영향을 받는다. 너무 작게 하면 하면 FIFO나 다름없다.
    * 다단계큐 : 우선순위가 다른 여러개의 큐를 준비하고 높은 우선순위의 큐먼저 처리한다.
        - 각각의 큐는 SRT로 진행된다. 할당된 시간동안 처리하지 못한 프로세스는 다음 우선순위 큐로 넣는다.
        - 입출력에 의해 선점된 경우 높은 우선순위로 할당한다.
        - 큐가 빌경우 다음 순위의 큐로 넘어간다.
        - 각 큐에서 작업이 진행되고 있을 때 우선순위가 높은 큐에 의해 선점되지 않는다.( 우선순위가 낮은 큐에서 작업중, 우선순위가 높은 큐에 프로세스가 들어오더라도 선점되지 않는다.)
    
## 메모리관리
메모리에 프로세스가 올라와야 프로그램이 실행된다. 메모리를 한정된 자원이기 때문에 올라온 프로세스에 대한 관리가 필요하다. 메모리에 올라온 프로세스의 개수에 따라 **단일, 다중 프로그래밍**으로 구분할 수 있다.

운영체제의 메모리 관리는 올라갈 프로세스를 언제 적제할 것인지, 메모리의 어느 공간에 적재 할 것인지, 필요없는 프로세스를 언제 교체할 것인지, 프로세스에게 메모리를 어느정도 할당할 것인지 등의 일을 하게 된다.

### 단일 프로그래밍
메모리에 하나의 프로세스만이 올라간다. 가장 단순하지만 자원의 낭비가 심하다. 프로세스가 하나밖에 없기 때문에 한번에 하나의 자원밖에 사용하지 못하기 때문에 선택되지 않은 자원들은 낭비된다. 메모리 또한 프로세스가 적재되고 남은 메모리들이 낭비된다. 커널에 대한 접근만 제한하면 된다.

### 고정 분할에서의 다중 프로그래밍
고정 분할은 메모리를 미리 특정한 크기로 분할 한 것을 의미한다. 메모리를 모두 같은 크기로 분할 하거나, 아니면 다른 크기로 분할 할 수 있다.(전체 100의 메모리를 20으로 5개 나누거나, 10,10,20,30,30 으로 미리 나눠 놓을 수 있다. - 이 때 메모리에 올라올 수 있는 프로세스의 최대 개수는 5개이다.) 프로세스를 메모리에 적재할때 지정된 메모리에만 적재한다.(절대로더)

단순한 방법으로 유연하지 못하다. 절대로드를 사용할 경우 나눠진 하나의 메모리구역에 여러 프로세스가 할당 될 수 있다. 이런 쏠림 현상을 위해 재배치의 과정이 필요하다. 각 프로세스가 할당된 메모리 구역이 아닌 다른 구역에 침범하지 못하게 메모리 상한과, 하한 값을 가지고 있어야한다. 메모리 구역의 크기가 정해져 있어 프로세스의 크기에 딱 맞지 않기 때문에 메모리가 낭비되는 내부, 외부 단편화가 생긴다.

내부 단편화 : 메모리 구역의 크기가 프로세스보다 크기때문에 낭비되는 메모리
외부 단편화 : 메모리 구역의 크키가 너무작아 사용되지 않는 메모리

### 가변 분할에서의 다중 프로그래밍
고정 분할과 달리 프로세스가 메모리에 올라올 때 동적으로 메모리를 분할 한다. 유연성이 크기때문에 복잡하고 메모리 사용현황에 대한 값을 저장하고 있어야하기 때문에 오버헤드가 발생한다.

프로세스가 메모리에 올라가는 과정을 그림으로 표현하면 다음과 같다.
```
1. 크기가 10Mbyte 인 process A의 적재
2. 크기가 20Mbyte 인 process B의 적재
3. 크기가 15Mbyte 인 process C의 적재
4. Process C의 메모리 반납
5. Process A의 메모리 반남
6. 크기가 50 Mbyte인 process D의 적재
7. 크기가 10 Mbyte인 process E의 적재
8. process B의 메모의 반납
```
![default](https://user-images.githubusercontent.com/24218456/50270379-ae63bc00-0474-11e9-8368-de1446298726.png)

#### 가변 분할에서의 메모리 선택 전략
1. 최초 적합
사용가능한 분할 된 메모리 리스트에서 처음 적합한 메모리를 선택한다. 빠르지만 외부 단편화가 발생한다.

2. 최적 적합
사용가능한 모든 메모리를 확인하여 남은 메모리가 가장 작은 메모리 공간을 선택한다. 모든 사용가능 메모리 리스트를 확인해야하기 때문에 시간이 오래걸린다. 남은 메모리가 작은 경우가 많기 때문에 외부단편화가 생긴다.

3. 최악 적합
사용가능한 모든 메모리를 확인하여 남은 메모리가 가장 큰 메모리 공간을 선택한다. 선택후 남은 공간이 큰 경우가 많기 때문에 외부 단편화를 줄일 수 있다.

### 남은 메모리 병합
지속적으로 메모리를 분할하다 보면 사용하지 못하는 메모리 공간이 생기기 때문에 남은 공간을 병합해 주어야한다. 메모리를 병합하는 방법은 2가지 방법이 있다.

1. 인접한 빈 공간의 병합
메모리를 반남하게 되면 인접한 공간이 있을 경우 병합한다.

2. 빈 공간 전부의 통합
사용중인 메모리를 한쪽으로 밀어 남은 메모리를 모두 병합한다. 사용중인 메모리를 옮겨야하는 작업이기 때문에 시간이 오래 걸린다.



## 페이징

> 페이징은 논리 주소 공간과 물리 주소 공간을 나누어 다루는 메모리 관리 기법이다.

* 즉, 가상 주소 공간을 만들어 이전의 문제들(스왑 아웃 시 디스크에서 연속적인 공간을 찾는 문제, 외부 단편화, 압축 등과 같은 기법을 사용함에 있어서 속도의 문제..)을 해결한다.

* 프로세스마다 보조 기억 장치로부터 주 기억 장치(메인 메모리)로 메모리를 할당하게 된다.

* 이 때, 연속된 메모리 공간을 할당하기 위해 오버헤드가 발생한다.

* 페이징 기법은 물리 주소 공간에서 연속적인 공간에 모여 있어야 한다는 제약을 없앤다.

* 물리 주소 공간에서는 연속적이지 않지만 가상 주소 공간에서 연속적으로 할당해 다루는 것이다.



*물리 메모리는 프레임(frame)이라고 불리는 고정 크기 블록, 논리 메모리는 페이지(page)라고 불리는 고정 크기 블록이 있다.*





![1](https://user-images.githubusercontent.com/20038567/47486911-5ba6c300-d87c-11e8-9a56-67e83b5a8047.png)

*(사진 출처 :  http://kdy-study.tistory.com/14)*



* 논리적(가상) 메모리에 페이지를 연속적으로 할당하고, 물리적 메모리에서 페이지가 들어있는 프레임은 흩어져 있게 된다.

* 페이지 테이블을 통해 페이지와 프레임을 매핑한다.



### 메모리 주소 매핑

> **x86 아키텍처 환경에서 논리 주소가 물리 주소로 어떻게 변환되는지 알아보자. (32비트 프로세스)**

*  32비트 프로세스에서는 `0x00000000 ~ 0xFFFFFFFF`의 주소 공간`4GB : 2^{32}`을 가진다. 그리고 페이지의 크기는 `4KB : 2^{12}`이다.

* 하나의 페이지는 x86과 AMD64에서는 4KB, IA64에서는 8KB의 크기를 가진다.

* 논리 주소 공간의 크기가 2의 m승이고, 페이지가 2의 n승이라면 논리주소(logical address)의 상위 m-n Bit는 페이지 번호를 하위 n비트는 페이지 변위(offset)을 나타낸다.



#### 1단계 페이징

> **기본적으로 위에서 알아본 페이징은 1단계 페이징이다.**

![2](https://user-images.githubusercontent.com/20038567/47486921-606b7700-d87c-11e8-9681-538a6796268b.PNG)



* 페이지 테이블의 항목(레코드)을 페이지 테이블 엔트리라 한다.

* 엔트리의 크기는 32비트 프로세스에서 일반적으로 4B(32비트)이며, 프레임 주소와 플래그 비트를 가진다.

* 프레임 주소는 엔트리 크기인 32비트에서 페이지 크기인 12비트를 뺀 20비트만큼 차지한다.

* 즉, 상위 20비트는 프레임의 주소, 하위 12비트는 플래그 비트이다.

* 엔트리에서 상위 20비트의 프레임 주소를 구하고, 하위 12비트는 페이지 변위(offset)를 더하면 32비트의 물리 주소를 구할 수 있다.



**페이지 크기, 페이지 테이블 크기, 엔트리 개수, 엔트리 크기 등의 개념을 잘 잡아야 한다. 위와 같은 환경에서는 다음과 같다.**

- 페이지 크기 = 4KB
- 엔트리 개수 = 1048576개(2^{20})
- 엔트리 크기 = 4B
- 페이지 테이블 크기 = 4MB (엔트리 개수 * 엔트리 크기)



**1단계 페이징에서 논리 주소를 물리 주소로 매핑하기**

​	1) 레지스터로 페이지 테이블의 시작 주소를 얻는다.

​	2) 시작 주소에 페이지 번호를 더해 페이지 테이블에 접근한다.

​	3) 페이지 테이블 엔트리에서 얻은 프레임 주소에 페이지 변위를 더해 최종 물리 주소를 구한다.



* 이 경우, 페이지 테이블을 저장하기 위해서만 4MB의 물리공간이 필요하다.

* 페이지 테이블의 크기가 커질 수록 주 메모리에서 연속적으로 할당되기를 기대할 수는 없다. 따라서 계층적 페이징이 등장하게 됐다.



#### 계층적 페이징

> **계층적 페이징은 페이지 테이블을 위한 페이지 테이블을 만드는 것이다. 즉, 페이지 테이블 자체가 다시 페이징 되는 것이다.(2단계 페이징 기법) 20비트의 페이지 테이블을 각 10비트씩 나눠보자.**



![3](https://user-images.githubusercontent.com/20038567/47486922-606b7700-d87c-11e8-9e8e-a52bf32d4098.PNG)



*이 경우 페이지 크기, 페이지 테이블 크기, 엔트리 개수, 엔트리 크기는 다음과 같다.*

- 페이지 크기 = 4KB
- 엔트리 크기 = 4B
- 첫 번째 페이지 테이블 엔트리 개수 = 1024개
- 첫 번째 페이지 테이블 크기 = 4KB
- 두 번째 페이지 테이블 엔트리 개수 = 1024개
- 두 번째 페이지 테이블 크기 = 4KB

2단계 페이징 기법에서 첫 번째와 두 번째 페이지 테이블을 각각 페이지 디렉토리, 페이지 테이블이라 부른다.



**2단계 페이징에서 논리 주소를 물리 주소로 매핑하기**

1) 레지스터에서 페이지 디렉토리의 시작 주소를 알아낸다.

2) 시작 주소에 페이지 디렉토리 인덱스를 더해 페이지 디렉토리에 접근한다.

3) 페이지 디렉토리 엔트리에서 페이지 테이블 시작주소를 알아낸다.

4) 페이지 테이블 시작주소에 페이지 테이블 인덱스를 더해 페이지 테이블에 접근한다.

5) 페이지 테이블 엔트리에서 프레임 주소를 알아낸다.

6) 프레임 주소에 페이지 변위를 더해 최종 물리 주소를 구한다.



![4](https://user-images.githubusercontent.com/20038567/47486923-606b7700-d87c-11e8-992e-59c19e7575e8.PNG)



> **그렇다면, 8MB의 메모리가 필요할 때 각 페이지 테이블은 몇 번 접근해야 할까?**

: 페이지 크기가 4KB이기 때문에 두 번째 페이지 테이블은 2048(2^{20} = 8MB/4KB)번의 접근이 필요하다. 두 번째 페이지 테이블을 2048번 접근하기 위해서는 첫 번째 페이지 테이블을 2번 접근해야 한다. 3단계 페이징 기법으로 확장 할 경우 페이지 테이블 할당을 위해 페이지 크기가 줄어들게 될 것이다. 해당 경우는 개인적으로 생각해보기 바란다.

---



## 교착상태

* 교착상태(Deadlock)이란 절대 발생하지 않을 사건을 기다리는 상황
* 두 개 이상의 프로세스들이 사용할 자원을 할당받기 위해서 기다리고 있어서 결과적으로 아무것도 완료되지 못하는 상태

#### 교착상태 발생 조건

* 상호배제(Mutual Exclusion) : 한 번에 한 프로세스만 해당 자원을 사용할 수 있어야 한다.
* 점유와 대기(Hold and Wait) : 프로세스가 한 개 이상의 자원을 할당받은 후 다른 프로세스에 할당된 자원을 기다리는 상태.
* 비선점 (No preemption) : 다른 프로세스가 사용중인 자원을 강제로 빼앗을 수 없다.
* 순환대기 (Circular wait) : 프로세스들이 순환을 이루어서 존재한다. 이를 구성하는 각 프로세스는 이전 프로세스가 요청하는 자원을 점유하고 다음 프로세스가 점유하고 있는 자원을 요청하는 경우. 순환대기는 점유대기, 비선점, 상호배제 조건을 만족해야 발생할 수 있는 현상이다.

#### 은행원 알고리즘

> 은행원 알고리즘은 프로세스가 자원을 요구할 때 시스템이 자우너을 할당한 후 안정 상태로 남아있게 되는지를 사전에 검사하여 교착상태를 회피하는 방법이다.

* 자원 할당 요청 -> 안정 여부 판단 -> 안정하면 자원 할당 -> 불안정하면 자원 할당 거부
* 여러 유형의 자원을 가진 시스템에서 사용된다. 
* 시스템이 자원을 할당한 후에도 안정 상태로 남아있는지 검사하여 안정 상태에 있으면 자원을 할당하고 그렇지 않으면 다른 프로세스들이 자원을 해제할 때까지 대기한다.
* **단점** : 
  * 할당할 수 있는 자원의 수가 일정해야한다.
  * 프로세스의 수가 일정 해야한다.
  * 항상 불안정 상태를 방지해야 하므로 자원 이용도가 낮다.



## 기아상태

#### 식사하는 철학자 문제

* 다수의 프로세스가 다수의 자원을 할당할 때의 상황을 나타낸 것.
* 철학자를 프로세스, 젓가락을 자원에 비교하여 설명
* 모든 철학자들이 모두 왼쪽 젓가락을 집고 오른쪽 젓가락을 집으려한다면 교착상태에 빠지게 되어 모두 굶게 된다.
* 교착 상태에 빠지지 않기 위해 철학자 4명만 테이블에 동시에 앉게 하는 방법, 양쪽 젓가락 모두 사용 가능할 때 젓가락을 집을 수 있도록 허용하는 방법 등으로 교착상태를 방지할 수 있지만 기아상태를 해결해주지는 못한다.
* 철학자 4명이 동시에 식사하는 방법을 선택했는데 나머지 한 명의 철학자에게 젓가락을 사용할 기회가 오지 않아서 굶주리는 상황을 기아상태(Starvation)이라고 한다.
* 기아상태란 필요한 자원들을 프로세스가 영원히 할당받지 못해서 계속 기다리고 있는 상태를 말한다.



*출처 : https://m.blog.naver.com/PostView.nhn?blogId=dong5053&logNo=220717510273&proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F*

