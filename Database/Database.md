# Database

### 목차

* [1장 데이터베이스 시스템](#1.-데이터베이스-시스템)
  * [데이터베이스의 특징](#데이터베이스의-특징)
  * [데이터베이스 시스템 개요](#데이터베이스-시스템-개요)
    * [데이터베이스 스키마와 상태](#데이터베이스-스키마와-상태)
    * [데이터베이스 시스템의 구성요소](#데이터베이스-시스템의-구성요소)
    * [데이터베이스 시스템의 요구사항](#데이터베이스-시스템의-요구사항)
  * [파일 시스템 방식과 DBMS 방식의 비교](#파일-시스템-방식과-dbms-방식의-비교)
  * [DBMS 언어](#dbms-언어)
  * [DBMS 사용자](#dbms-사용자)
  * [데이터베이스 시스템 아키텍쳐](#데이터베이스-시스템-아키텍쳐)
    * [클라이언트 서버 데이터베이스 시스템](#클라이언트-서버-데이터베이스-시스템)
* [2장 관계 데이터 모델과 제약조건](#2장-관계-데이터-모델과-제약조건)
  * [기본적인 용어](#기본적인-용어)
  * [스키마와 인스턴스](#스키마와-인스턴스)
  * [릴레이션의 특성](#릴레이션의-특성)
  * [릴레이션의 키](#릴레이션의-키)
  * [무결성 제약조건](#무결성-제약조건)
  * [무결성 제약조건의 유지](#무결성-제약조건의-유지)
* [3장 관계 대수와 SQL](#3장-관계-대수와-sql)
  * [관계 대수](#관계-대수)
  * [SQL](#sql)
    * [데이터 정의어](#데이터-정의어)
    * [제약조건](#제약조건)
  * [SELECT문](#select문)
    * [기본적인 SELECT 문](#기본적인-select-문)

---

## 1. 데이터베이스 시스템

> 데이터베이스는 조직체의 응용 시스템들이 공유해서 사용하는 운영 데이터들이 구조적으로 통합된 모임이다.

### 데이터베이스의 특징

* 데이터베이스는 데이터의 대규모 저장소로서, 여러 부서에 속하는 여러 사용자에 의해 동시에 사용된다. 더 이상 데이터를 한 사용자 또는 한 부서에서 소유하지 않는다. 데이터베이스는 이제 조직체의 모든 구성원이 공유하는 자원이다
* 중복된 데이터를 갖는 별도의 파일들로 유지되는 대신에 데이터베이스에서는 모든 데이터가 중복을 최소화하면서 통합된다.
* 데이터베이스는 한 조직체의 운영 데이터뿐만 아니라 그 데이터에 관한 설명까지 포함한다. 이런 설명을 데이터베이스 스키마 또는 메타데이터라고 한다. 메타데이터는 데이터에 관한 데이터라는 뜻이다.
* 데이터의 구조가 프로그램과 분리되어 데이터베이스에 저장되므로 프로그램과 데이터 간의 독립성이 제공된다.
* 데이터베이스는 효육적으로 접근이 가능하고 질의를 할 수 있다.

### 데이터베이스 시스템 개요

#### 데이터베이스 스키마와 상태

* **데이터베이스 스키마** : 전체적인 데이터베이스 구조를 뜻하며 자주 변경되지 않는다. 데이터베이스의 모든 가능한 상태를 미리 정의한다. 내포(intension)이라고 부르기도 한다.
* **데이터베이스 상태** : 특정 시점의 데이터베이스의 내용을 의미하며, 시간이 지남에 따라 계속해서 바뀐다. 데이터베이스 상태를 외연(extension)이라고 부르기도 한다.

#### 데이터베이스 시스템의 구성요소

> 데이터베이스 시스템(DBS : Database System)은 데이터베이스, 사용자(응용 프로그램), DBMS, 하드웨어로 구성된다. 

![default](https://user-images.githubusercontent.com/14870706/47412953-fda8ab80-d7a7-11e8-8cd5-524a394fb653.jpeg)

* **데이터베이스** : 데이터베이스는 조직체의 응용 시스템들이 공유해서 사용하는 운영 데이터들이 구조적으로 통합된 모임이다.
* **시스템 카탈로그** : 저장된 데이터베이스의 스키마 정보를 유지한다. 사용자가 새로운 테이블을 만들거나 기존의 테이블에 새로운 애트리뷰트를 추가하는 작업 등을 수행하면 시스템 카탈로그에 이를 반영하는 스키마 정보가 삽입된다.
* **DBMS** : 실세계는 동적이기 때문에 계속해서 엔티티가 생성, 수정, 삭제된다. 적은 수라면 수작업으로 관리 가능하지만, 수십개 이상의 엔티티가 연관되고 비즈니스의 규모가 매우 크다면 비즈니스의 상태를 유지하는 것이 더 이상 수작업으로는 불가능해진다. 그래서 DBMS는 사용자가 새로운 데이터베이스를 생성하고 데이터베이스 구조를 명시할 수 있게 하고, 사용자가 데이터를 효율적으로 질의하고 수정할 수 있도록 하며, 시스템의 고장이나 권한이 없는 사용자로부터 데이터를 안전하게 보호하며, 동시에 여러 사용자가 데이터베이스를 접근하는 것을 제어하는 소프트웨어 패키지이다.
* **SQL** : 여러 DBMS에서 제공되는 사실상의 표준 데이터베이스 언어이다.
* **하드웨어** : 데이터베이스는 디스크와 같은 보조 기억 장치에 저장되며, DBMS에서 원하는 정보를 찾기 위해서는 디스크의 블록들을 주기억 장치로 읽어들여야 한다. 또한 계산이나 비교 연산들을 수행하기 위해 중앙 처리 장치가 사용된다. DBMS 자체도 주기억 장치에 적재되어 실행되어야 하므로 하드웨어 자원들을 필요로 한다.

#### 데이터베이스 시스템의 요구사항

* **데이터의 독립성** : 응용 프로그램이 데이터 표현의 상세한 내역과 데이터 저장으로부터 독립적이다 (파일 시스템과는 반대)
* **융통성** : 기존의 응용 프로그램에 영향을 주지 않으면서 데이터베이스 구조를 변경할 수 있어야한다.
* **효율적인 데이터 접근** : 방대한 데이터베이스를 효율적으로 저장하고 접근하기 위해서 다수의 정교한 기법을 제공해야한다. 일반적으로 인덱스 구조가 이런 목적으로 사용된다.
* **데이터에 대한 동시 접근** : 여러 사용자가 동일한 데이터베이스를 동시에 접근하는 경우가 많다. 각 사용자가 혼자서 데이터베이스를 접근하는 것처럼 인식하도록 데이터베이스에 대한 동시 접근을 동기화하기 위한 동시성 제어를 제공해야 한다.
* **백업과 회복** : 시스템 에러 등으로부터 데이터베이스를 회복하며, 디스크 등이 손상을 입는 경우를 대비해서 백업을 수행한다.
* **중복을 줄이거나 제어하여 일관성 유지** : 데이터를 통합함으로써 동일한 데이터가 여러 개의 사본으로 존재하는 것을 피한다. 성능을 향상시키기 위해 중복을 일부 허용하고 제어할 수 있다.
* **데이터 무결성** : 데이터 무결성은 의미적인 측면에서 데이터가 정확하고 완전함을 의미한다. 사용자가 무결성 제약조건을 정의하면 DBMS는 데이터를 삽입, 삭제, 수정할 때 마다 제약조건을 자동적으로 검사한다. 
* **데이터 보안** : 권한이 없는 접근으로부터 데이터베이스를 보호한다.
* **쉬운 질의어**
* **다양한 사용자 인터페이스의 제공**

*파일 시스템은 이 모든 것들의 반대이다.*

### 파일 시스템 방식과 DBMS 방식의 비교

|                       파일 시스템 방식                       |                          DBMS 방식                           |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|             데이터에 대한 물리적 접근만 조정한다             |  데이터에 대한 물리적 접근과 논리적인 접근을 모두 조정한다.  |
| 동일한 파일을 두 개 이상의 프로그램이 동시에 접근할 수 없다. |     동일한 데이터를 다수 사용자가 동시에 접근할 수 있다      |
|    데이터가 비구조적이며, 중복성과 유지보수 비용이 높다.     |  데이터가 구조화되어 있으며, 중복성과 유지보수 비용이 낮다.  |
| 어떤 프로그램이 기록한 데이터는 다른 프로그램에서 읽을 수 없는 경우가 많다. |     접근 권한이 있는 모든 프로그램이 데이터를 공유한다.      |
| 데이터에 대한 접근은 미리 작성된 프로그램을 통해서만 가능하다. | 질의어를 사용하여 데이터에 대한 융통성 있는 접근이 가능하다. |
| 각 응용 프로그램마다 파일이 따로 있으므로 데이터가 통합되어 있지 않다. |          데이터가 중복을 배제하면서 통합되어 있다.           |

---

### DBMS 언어

* **데이터 정의어(DDL : Data Definition Language)** : 사용자는 데이터 정의어를 사용하여 데이터베이스 스키마를 정의한다. DBMS는 사용자가 정의한 스키마에 대한 명세를 시스템 카탈로그 또는 데이터 사전에 저장한다. 시스템 카탈로그는 메타데이터를 저장한다. 메타데이터는 데이터베이스에 저장된 데이터에 관한 데이터를 말한다. 
  * EX > CREATE, ALTER, DROP
* **데이터 조작어(DML : Data Manipulation Language)** : 사용자는 데이터 조작어를 사용하여 데이터베이스 내의 원하는 데이터를 검색하고 수정하고 삽입하고 삭제한다. 그리고 대부분의 데이터 조작어에는 SUM, COUNT, AVG와 같은 내장 함수들이 있는데, 이것들은 C, COBOL과 같은 호스트 언어들을 사용하여 제작된 프로그램에 내포되어 사용된다. 그 이유는 데이터 조작어에는 조건문, 반복문, 입력문 등이 없기 때문이다
  * EX > SELECT, UPDATE, DELETE, INSERT
* **데이터 제어어(DCL : Data Control Language)** : 사용자는 데이터 제어어를 사용하여 데이터베이스 트랜잭션을 명시하고 권한을 부여하거나 취소한다. 해당 개념은 후에 트랜잭션을 다루면서 추가적으로 설명하겠다.

---

### DBMS 사용자

* **데이터베이스 관리자 (DBA : Database Administrator)** : 조직의 여러 부분의 상이한 요구를 만족시키기 위해서 일관성 있는 데이터베이스 스키마를 생성하고 유지하는 사람을 말한다. 하는 일은 다음과 같다.
  * 데이터베이스 스키마의 생성과 변경
  * 한꺼번에 적재(bulk loading)
  * 무결성 제약조건을 명시
  * 사용자의 권한을 허용하거나 취소하고, 사용자의 역할을 관리
  * 저장 구조와 접근 방법(물리적 스키마) 정의
  * 백업과 회복
  * 표준화 시행
* **응용 프로그래머** : 데이터베이스 위에서 특정 응용 프로그램이나 인터페이스를 구현하는 사람으로서 `DML`의 주요 사용자다. 이들이 작성한 프로그램은 최종 사용자들이 반복해서 수행하므로 **'기작성 트랜잭션(Canned Transaction)'**이라고 부른다.
* **End User(최종 사용자)** : 최종 사용자는 질의하거나 갱신하거나 보고서를 생성하기 위해서 데이터베이스를 사용하는 사람으로서 데이터 정의어나 데이터 조작어를 직접 사용하는 경우는 비교적 많지 않다.
* **데이터베이스 설계자** : ERWin, CASE 도구들을 이용해서 데이터베이스 설계를 책임진다. 데이터베이스의 일관성을 유지하기 위해서 정규화를 수행한다. 데이터베이스를 효율적으로 접근할 수 있도록 인덱스 등을 정의한다. 설계에 관한 문서화 작업도 한다

---

### 데이터베이스 시스템 아키텍쳐

![ë°ì´í°ë² ì´ì¤ ìì¤í ìí¤íì²ì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](https://t1.daumcdn.net/cfile/tistory/2434CC5055F2A8942E)

* 데이터베이스 관리자가 **데이터 정의어**를 사용하여 테이블 생성을 요청
* **데이터 정의어 컴파일러**가 이를 번역하여 테이블이 파일 형태로 데이터베이스에 만들어진다
* 이 테이블에 대한 명세가 **시스템 카탈로그에 저장**된다.
* 최종 사용자나 응용 프로그래머가 데이터 조작어를 사용하여 데이터베이스를 접근하려 하면 DBMS의 **질의 처리기**를 통해서 기계어 코드로 번역된다.
* DBMS의 **런타임 데이터베이스 관리기**에 의해 데이터베이스가 접근된다.
* 이 과정에서 사용자가 원하는 테이블이 데이터베이스에 존재하는가, 데이터 조작어를 입력한 사용자가 해당 테이블을 접근할 수 잇는 권한이 있는가, 테이블에 어떤 접근 경로들이 존재하는가 등을 **시스템 카탈로그를 접근하여 확인**한다.
* 여러 사용자가 공용 데이터베이스를 접근할 때 생길 수 있는 데이터 불일치를 해결하기 위해서 **동시성 제어 모듈이 사용**된다.
* 데이터베이스를 접근하는 도중에 시스템이 다운되면, 다운되기 직전의 일관된 데이터베이스 상태를 복구하기 위해서 **회복 모듈**이 사용된다.
* 동시성 제어 모듈과 회복 모듈을 합쳐서 **트랜잭션 관리 모듈**이라 부른다.

#### 클라이언트 서버 데이터베이스 시스템

> 클라이언트-서버 아키텍처는 클라이언트와 데이터베이스 서버가 직접 연결되는 **2-tier Model**과, 클라이언트와 데이터베이스 서버 사이에 **응용 서버**(Application Server)가 추가된 **3-tier Model**로 구분한다.

* **2-Tier Model** : 어플리케이션의 논리(DB관련 로직)가 클라이언트와 서버에 흩어져 있다.
* **3-Tier Model** : 어플리케이션의 논리가 어플리케이션 서버에만 포함되어 있다. 서비스 요청과 응답이 클라이언트와 어플리케이션 서버 간에만 전송되기 때문에 성능이 향상된다. 또한 응용 소프트웨어를 다수의 클라이언트 대신에 소수의 어플리케이션 서버에 설치하게 되므로 구현 및 유지보수가 용이하다.

클라이언트-서버 데이터베이스 시스템의 장점은 기존의 데이터베이스를 보다 넓은 지역에서 접근할 수 있고, 성능이 향상되며, 하드웨어 비용이 절감된다는 것이다. 또한 다양한 컴퓨터 시스템을 사용할 수 있다. 예를 들어, 클라이언트는 PC에서 윈도우 운영 체제를 사용하고, 서버는 워크스테이션이나 메인프레임에서 UNIX 운영 체제를 사용할 수 있다. 보안이 다소 취약할 수 잇따는 것은 클라이언트-서버 데이터베이스 시스템의 단점이다.



---

## 2장 관계 데이터 모델과 제약조건

### 기본적인 용어

* **릴레이션** : 2차원 테이블을 의미한다. 이 모델에서 정보는 **행(=투플=레코드), 열(=애트리뷰트)**로 표현된다.

* **카디날리티** : 행들의 수

* **차수(Degree)** : 열들의 수

* **도메인** : 한 애트리뷰트에 나타날 수 있는 값들의 집합이다. (원자값)

  * ```sql
    - CREATE DOMAIN EMPNO INTEGER
    - CREATE DOMAIN EMPNO2 INTEGER
    ```

    둘다 정수형이지만 서로 의미가 다른 도메인이므로 비교 연산이 불가능해진다. 의미 있는 연산들만 허용하기 위해 사용된다.


### 스키마와 인스턴스

> 스키마는 릴레이션을 위한 틀이다. 릴레이션 스키마는 아래와 같은 표기법을 사용하여 나타낸다.

* 릴레이션이름(<u>애트리뷰트1</u> … 애트리뷰트N) - 밑줄 친 부분은 Primary Key이다.

> 릴레이션 인스턴스는 릴레이션에 어느 시점에 들어 있는 투플들의 집합니다.

* 릴레이션 인스턴스는 정적이지 않고 시간의 흐름에 따라 계속 변한다.


### 릴레이션의 특성

* 각 릴레이션은 오직 하나의 레코드 타입만 포함한다.

* 한 애트리뷰트 내의 값들은 모두 같은 유형이다.

* 애트리뷰트들의 순서는 중요하지 않다. (순서가 달라도 같다)

  * 관계 모델에서 애트리뷰트 값은 릴레이션 내에서의 애트리뷰트의 위치에 의해서가 아니고 애트리뷰트의 이름에 의해서 참조된다.

* 릴레이션이 투플들의 집합이기 때문에 동일한 투플이 두 개 이상 존재하지 않는다. 

  * 한 릴레이션에 동일한 두 투플이 두 개 이상 존재하지 않는다는 특성을 시행하려면 DBMS의 오버헤드가 증가하기 때문에 상용 관계 DBMS에서는 사용자가 명시하지 않는 한 일반적으로 이 특성을 시행하지 않는다. 즉 상용 관계 DBMS가 관리하는 테이블에는 중복된 투플들이 존재할 수 있다.

* 한 투플의 각 애트리뷰트는 원자값을 갖는다.

  | DEPTNO | DEPTNAME | FLOOR            |
  | ------ | -------- | ---------------- |
  | 1      | 영업     | {8 , 9} - 불가능 |
  | 2      | 기획     | 10               |
  | 3      | 개발     | {7, 9} - 불가능  |

* 릴레이션이 투플들의 집합이기 때문에 투플들의 순서는 중요하지 않다.

* 각 애트리뷰트의 이름은 한 릴레이션 내에서만 고유하다



### 릴레이션의 키

* **수퍼 키** : 수퍼 키는 한 릴레이션 내의 특정 투플을 고유하게 식별하는 하나의 애트리뷰트 또는 애트리뷰트들의 집합이다.
  * `(신용카드번호, 주소)` 또는 `(주민등록번호, 이름)` 모두 수퍼 키가 될 수 있다. 
  * 신용카드번호나 주민번호를 포함하는 어떠한 집합도 수퍼 키 이다.
  * **문제점** : 투플들을 고유하게 식별하는데 꼭 필요하지 않은 애트리뷰트들을 포함할 수 있다는 것
* **후보 키** : 후보 키는 각 투플을 고유하게 식별하는 최소한의 애트리뷰트들의 모임이다. 즉 후보 키를 구성하는 애트리뷰트들 중에서 어느 한 애트리뷰트라도 빼면 고유하게 식별하는 능력을 상실한다.
  * `(신용카드번호, 주소)`는 신용카드 회사의 고객 릴레이션의 후보 키가 아니지만 `(신용카드번호)`는 후보 키다.
  * 후보 키도 두개 이상의 애트리뷰트로 이루어질 수 있으며 이런 경우에 **복합 키(composite key)**라고 부른다.
* **기본 키(primary key)** : 한 릴레이션에 후보 키가 두 개 이상 있으면 데이터베이스 설계자 또는 데이터베이스 관리자가 이들 중에서 하나를 기본 키로 선정한다. 즉, 후보 키 중에 하나 골라서 기본 키로 명명하면 그게 기본 키가 되는 것이다.
  * 기본 키는 한 릴레이션 내의 모든 투플을 고유하게 식별할 수 있어야 하므로ㅜ 널값이나 중복된 값을 가질 수 없다. 한 릴레이션의 기본 키를 선정할 때 추가로 고려할 사항은 다음과 같다.
    * 애트리뷰트가 항상 고유한 값을 가질 것인가
    * 애트리뷰트가 확실하게 널값을 갖지 않을 것인가
    * 애트리뷰트의 값이 변경될 가능성이 높은 애트리뷰트는 기본 키로 선정하지 말 것
    * 가능하면 작은 정수 값이나 짧은 문자열을 갖는 애트리뷰트
    * 가능하면 복합 기본 키를 피할 것
* **대체 키** : 대체 키는 기본 키로 선정되지 않은 후보 키를 말한다. 신용카드 회사의 고객 릴레이션에서 신용카드번호를 기본 키로 선정하면 주민등록번호는 대체 키가 된다.

<u>지금까지 릴레이션 키들의 관계를 정리해보면,  수퍼키 > 후보키 > 기본키|대체키 로 표현할 수 있다.</u>

* **외래 키** : 외래 키는 어떤 릴레이션의 기본 키를 참조하는 애트리뷰트이다. 외래 키는 관계 데이터베이스에서 릴레이션들 간의 관계를 나타내기 위해서 사용된다. 외래 키의 유형을 몇 가지로 구분하여 살펴보겠다.

  * 다른 릴레이션의 기본 키를 참조하는 외래 키

    **EMPLOYEE 테이블**

    | <u>EMPNO</u> | EMPNAME | DNO (외래키) |
    | ------------ | ------- | ------------ |
    | 2104         | 김창섭  | 2            |
    | 1232         | 박영권  | 3            |
    | 1003         | 조민희  | 1            |

    **DEPARTMENT 테이블**

    | <u>DEPTNO</u> | DEPTNAME | FLOOR |
    | ------------- | -------- | ----- |
    | 1             | 영업     | 8     |
    | 2             | 기획     | 10    |
    | 3             | 개발     | 9     |

  * 자체 릴레이션의 기본 키를 참조하는 외래 키

    | EMPNO | EMPNAME | MANAGER(외래키) |
    | ----- | ------- | --------------- |
    | 2106  | 김창섭  | 3426            |
    | 3426  | 박영권  | 3011            |
    | 3011  | 이수민  | ^               |

  * 기본 키의 구성요소가 되는 외래 키

    * 학생(<u>학번</u>, 이름), 수강(<u>학번</u>, <u>과목번호</u>, 학점), 과목(<u>과목번호</u>, 과목이름) 이라는 테이블이 있다고 가정하자. 수강이라는 테이블의 기본키는 학번+과목번호이다. 그리고 학번은 학생 테이블의 학번을 참조하는 외래키이고, 과목번호는 과목이라는 테이블의 과목번호를 참조하는 외래키이다. 이것들이 모여 수강이라는 테이블에서 기본 키를 이루고 있다.



### 무결성 제약조건

> **무결성 제약조건은 다음과 같은 상황을 방지하기 위해서 필요하다.**

* 어떤 학생이 수강 신청을 했으나 학생들에 관한 정보를 포함하고 있는 릴레이션에 이 학생에 대한 데이터가 없다.
* 질의 처리 과정에 학생의 학번과 과목의 번호를 비교한다.
* 학생이 대학을 그만 두어서 학생 릴레이션에서는 이 학생에 대한 데이터가 삭제 되었으나 수강 릴레이션에는 여전히 남아 있다.

> **그렇다면 무결성 제약조건의 장점은?**

 : 스키마를 정의할 때 일관성 조건을 오직 한 번만 명시하고, 데이터베이스가 갱신될 때 DBMS가 자동적으로 일관성 조건을 검사하므로 응용 프로그램들은 일관성 조건을 검사할 필요가 없다는 것이다.



#### 도메인 제약조건

* 가장 간단한 형태의 제약조건
* 각 애트리뷰트 값이 반드시 원자값이어야 한다
* 데이터 형식을 통해 값들의 유형을 제한 한다.
* 애트리뷰트의 디폴트 값을 지정한다
* 애트리뷰트에 저장되는 값들의 범위를 제한할 수 있다.
* NOT NULL 구문을 통해 해당 애트리뷰트의 값이 존재하도록 보장한다.



#### 키 제약조건

* 키 애트리뷰트에 중복된 값이 존재해서는 안된다는 것이다
* UNIQUE나 기본키로 명시한 애트리뷰트에는 중복된 값이 허용되지 않는다.



#### 기본 키와 엔티티 무결성 제약조건

* 두 개 이상의 투플이 동일한 기본 키 값을 가질 수 없다.
* 릴레이션의 기본 키를 구성하는 어떤 애트리뷰트도 널값을 가질 수 없다



#### 외래 키와 참조 무결성 제약조건

* 두 엔티티 간의 관계도 관계 모델에서는 릴레이션으로 표현된다 (EX > 학생 - 수강(관계) - 과목)
* 두 릴레이션의 연관된 투플들 사이의 일관성을 유지하는데 사용되는 제약조건이다.
* 관계 데이터베이스가 포인터 없이 오직 릴레이션들로만 이루어지고, 릴레이션 사이의 관계들이 다른 릴레이션의 기본 키를 참조하는 것을 기반으로 하여 묵시적으로 표현되기 때문에 외래 키의 개념이 중요하다.
  * 외래 키의 값은 R1의 어떤 투플의 기본 키 값과 같다, 외래 키가 자신을 포함하고 있는 릴레이션의 기본 키를 구성하고 있지 않으면 널값을 가진다. 이 두 조건 중 하나가 성립되면 참조 무결성 제약조건을 만족한다.



### 무결성 제약조건의 유지

> DDL로 만들어진 현재 데이터베이스가 무결성 제약조건을 모두 만족한다고 하더라도, 갱신 연산(삽입, 수정, 삭제)이 일어나면 무결성이 파괴될 수 있다. DBMS는 외래 키가 갱신되거나, 참조된 기본 키가 갱신되었을 때 참조 무결성 제약조건이 위배되지 않도록 해야한다. DBMS가 갱신 연산을 거절하거나, 갱신을 전파하여 다른 갱신들이 자동적으로 수행되도록 하여야 한다.

* **삽입** 
  * 도메인 제약조건, 키 제약조건, 엔티티 무결성 제약조건 등은 위배할 수 있다.
    * EX > 똑같은 투플 삽입, 기본키 null 값 투플 삽입 등
  * 참조 무결성에서는 **참조하는 쪽**에서 무결성 위반이 일어날 수 있다
    *  EX > 없는 곳을 참조하기. 
    * **참조 당하는 쪽**에 삽입이 일어나면 참조 무결성을 해치는 경우는 발생하지 않는다.
* **삭제** 
  * 참조하는 릴레이션에서 투플이 삭제되면 모든 제약조건을 위배하지 않는다.
  * 참조되는 릴레이션에서 투플이 삭제되면 참조 무결성 제약 조건을 위배하는 경우가 생길 수도 있다.
    * EX > 해당 투플을 참조하고 있는 것이 있으면 무결성 제약 조건 위반
  * 참조 무결성 제약조건을 만족시키기 위해 DBMS는 몇 가지 옵션을 제공한다
    * **제한(restricted)** : 위배를 야기한 연산을 단순히 거절한다.
    * **연쇄(cascade)** : 참조되는 릴레이션에서 투플을 삭제하고, 참조하는 릴레이션에서 이 투플을 참조하는 투플들도 함께 삭제한다. (연관된 놈 다 죽이는 옵션)
    * **널 값** : 참조되는 릴레이션에서 투플을 삭제하고, 참조하는 릴레이션에서 이 투플을 참조하는 투플들의 애트리뷰트 값에 null 값을 넣어준다. (not null 일 경우 삭제 연산 거절)
    * **디폴트 값** : 널 값 대신에 디폴트 값을 넣는 옵션이다.
* **수정** 
  * 수정하는 애트리뷰트가 기본 키인지 외래 키인지 검사한다. (기본 키, 외래 키가 아니면 무결성 해칠 이유가 없으므로)
  * 기본 키, 외래 키에 해당한다면 하나의 투플을 삭제하고 새로운 투플을 그 자리에 삽입하는 것과 유사하므로 삽입과 삭제 규칙이 수정에도 고스란히 적용된다.

* **릴레이션** : 2차원의 테이블을 의미한다. 정보는 **행(=레코드=투플)**, **열(=애트리뷰트)**들로 표현된다.
* **카디날리티** : 행들의 수
* **Degree(차수)** : 열들의 수

* **도메인** : 한 애트리뷰트에 나타날 수 있는 값들의 집합 (원자값)

  * ```sql
    CREATE DOMAIN EMPNO INTEGER
    ```

  * ```sql
    CREATE DOMAIN DNO INTEGER
    ```

  * 서로 다른 도메인이므로 같은 INTEGER 값이어도 비교할 수 없게 된다.


---
## 3장 관계 대수와 SQL
> 관계 데이터베이스에 정보를 저장하고 검색하는 언어가 필요하다. 관계 데이터 모델에서 지원되는 정형적인 언어에는 두 가지가 있다. **관계 해석(relational calculus)**은 원하는 데이터만 명시하고 질의를 어떻게 수행할 것인가는 명시하지 않는 선언적인 언어이고, **관계 대수(relational algebra)**는 어떻게 질의를 수행할 것인가를 명시하는 절차적 언어이다.

### 관계 대수
* 관계 대수는 관계 해석과 함께 릴레이션을 다루는 대표적인 이론적 방법이다. 관계 대수는 기존의 릴레이션들로부터 새로운 릴레이션을 생성한다. 릴레이션이나 관계 대수식에 연산자들을 적용하여 보다 복잡한 관계 대수식을 점차적으로 만들 수 있다.

* 관계 대수는 기본적인 연산자들의 집합으로 이루어진다. 하나의 관계 연산은 한 개 이상의 입력 릴레이션에 연산자를 적용하여 새로운 릴레이션 하나를 결과로 생성한다. 이는 산술 연산과 원리면에서 유사하다. 

*관계 대수와 관련된 내용은 중요하지 않다고 생각하여 정리하지 않겠습니다. 궁금하신 분들은 구글링~*

### SQL

> **SQL을 사용하면 자연어에 가까운 구문을 사용하여 질의(Query)를 표현할 수 있다는 것이다. SQL은 비절차적 언어이므로 사용자는 자신이 원하는 데이터만 명시하며, 원하는 것을 처리하는 방법은 명시할 수 없다.**

* **데이터 정의어** : CREATE
* **데이터 조작어** : SELECT, INSERT, DELETE, UPDATE
* **데이터 제어어** : 사용자는 데이터 제어어를 사용하여 트랜잭션의 시작, 철회, 완료 등을 명시하고, 릴레이션에 대한 권한을 부여하거나 취소하고, 어떤 관계 DBMS에서는 동시성 제어를 위해 데이터를 로크하는 수준을 지정한다.

#### 데이터 정의어

* **스키마의 생성과 제거**

  * 일반적으로 스키마는 특정 사용자의 데이터베이스 어플리케이션에 속하는 릴레이션, 도메인, 제약조건, 뷰, 권한 등을 그룹화한 것이다. 각 사용자는 권한을 허가받지 않은 한 다른 사용자의 스키마에 속한 데이터를 볼 수 없다.

  * 스키마는 **CREATE SCHEMA**문을 사용하여 생성한다. 

    EX> 

    ```sql
    CREATE SCHEMA MY_DB AUTHORIZATION KIM;
    
    DROP SCHEMA MY_DB
    ```

* **릴레이션 정의**

  * SQL에서 릴레이션을 정의하는 문은 **CREATE TABLE**이다.

  * Foreign key가 걸려있는 릴레이션을 먼저 만들어줘야 한다 (당연)

  * 애트리뷰트의 데이터 타입을 결정할 때 고려해야 할 사항

    * 1. 숫자인지 문자인지를 먼저 결정한다.
      2. 문자인 경우에는 고정 길이 또는 가변 길이, 최대 길이
      3. 숫자인 경우에는 정수 또는 실수, 최대 길이, 소숫점 아래 개수

  * EX> 

    ```sql
    CREATE TABLE DEPARTMENT
    
    (DEPTNO	INTEGER	NOT NULL,
    
    PRIMARY KEY(DEPNO));
    ```

    EX> 

    ```sql
    CREATE TABLE EMPLOYEE
    
    (DNO	INTEGER
    
    FOREIGN KEY(DNO) REFERENCES DEPARTMENT(DEPTNO));
    ```



    | 데이터 타입                               | 의미                                             |
    | ----------------------------------------- | ------------------------------------------------ |
    | INTEGER 또는 INT                          | 정수형                                           |
    | SMALLINT                                  | 작은 정수형                                      |
    | NUMBER(n, s) 또는 DECIMAL(n, s)           | n개의 숫자에서 소수 아래 숫자가 s개인 십진수     |
    | REAL                                      | 실수                                             |
    | FLOAT(n)                                  | 적어도 n개의 숫자가 표현되는 실수형              |
    | CHAR(n) 또는<br />CHARACTER(n)            | n바이트 문자열. n을 생략하면 1                   |
    | VARCHAR(n) 또는<br />CHARACTER VARYING(n) | 최대 n바이트까지의 가변 길이 문자열              |
    | BIT(n) 또는 <br />BIT VARYING(n)          | n개의 비트열 또는 최대 n개까지의 가변 비트열     |
    | DATETIME                                  | 날짜형                                           |
    | BLOB                                      | BINARY LARGE OBJECT, 멀티미디어 데이터 등을 저장 |

  * **DROP TABLE** (테이블 삭제)

  * Foreign key가 걸려있으면 테이블 삭제가 되지 않으므로 **ALTER TABLE** 명령어를 이용해서 Foreign Key 조건을 삭제해야한다.

* **ALTER TABLE**

  * 테이블에 새로운 제약조건을 추가, 테이블에서 애트리뷰트 삭제 및 추가, 테이블에서 제약조건을 제거, 애트리뷰트의 데이터 타입 변경, 애트리뷰트의 디폴트 값 지정, 애트리뷰트의 디폴트 값 제거 등이 있다. 

    EX> 

    ```sql
    ALTER TABLE EMPLOYEE ADD PHONE CHAR(13);
    ```

* **인덱스 생성**

  * **CREATE INDEX**문은 SQL의 표준은 아니지만 대부분의 상용 관계 DBMS가 지원한다.

  * CREATE INDEX문은 릴레이션의 하나 이상의 애트리뷰트에 대해 인덱스를 생성한다.

  * 뷰에는 인덱스를 생성할 수 없다.

  * 뷰는 뷰의 정의에 사용된 기본 릴레이션에 생성된 인덱스를 사용하게 된다

  * 인덱스는 검색 성능을 향상시키기 위해 사용된다.

  * 하지만 인덱스는 저장 공간을 추가로 필요로 하고 갱신 연산의 속도를 저하시킨다.

  * 인덱스의 디폴트는 오름차순이다

  * 인덱스가 정의된 릴레이션의 투플에 변경이 생기면 DBMS가 자동적으로 인덱스에 반영한다.

    EX> 

    ```sql
    CREATE INDEX EMPDNO_IDX ON EMPLOYEE(DNO);
    
    DROP INDEX EMPLOYEE.EMPDNO_IDX;
    ```

* **도메인 생성**

  * 도메인의 장점은 한 스키마의 여러 애트리뷰트에서 사용되는 어떤 도메인의 데이터 타입을 쉽게 변경할 수 있다는 것이다. 도메인을 정의한 곳에서 도메인 정의를 변경하면 도메인 정의를 사용하는 모든 곳에서 일관되게 적용된다. 도메인 정의에 디폴트값을 지정할 수 있다.

    ```sql
    CREATE DOMAIN DEPTNAME CHAR(10) DEFAULT '개발';
    
    DROP DOMAIN DEPTNAME RESTRICT;
    ```


#### 제약조건

* **NOT NULL :** 애트리뷰트는 디폴트로 널값을 가질 수 있기 때문에 만일 어떤 애트리뷰트에 널값을 허용하지 않으려면 'NOT NULL'을 명시해야한다.

* **UNIQUE** : 동일한 애트리뷰트 값을 갖는 투플이 두 개 이상 존재하지 않도록 보장한다. NOT NULL을 명시하지 않았다면 한 개의 투플에서는 이 애트리뷰트에 널값을 가질 수 있다.

* **DEFAULT** : 널값 대신 디폴트 값 지정 가능

* **CHECK** : 한 애트리뷰트가 가질 수 잇는 값들의 범위를 지정한다. EX > 

  ```sql
  CHECK (MANAGER_SALARY > SALARY)
  ```




### SELECT문

> **관계 데이터베이스에서 정보를 검색하는 SQL문은 SELECT문이다.**

#### 기본적인 SELECT 문

```sql
SELECT	[DISTINCT] 애트리뷰트(들)
FROM	릴레이션(들)
--- 선택 ---
WHERE	조건
GROUP BY	애트리뷰트(들)
HAVING	조건
ORDER BY	애트리뷰트(들) [ASC|DESC]
```

* DISTINCT를 적어주면 중복이 제거된다.
* WHERE절은 아래와 같은 사항들을 포함한다.
  * 비교 연산자 : =, <>, <, <=, >, >=
  * 부울 연산자 : AND, OR, NOT
  * 집합 연산자 : IN, NOT IN, ANY(SOME), ALL
* **중첩 질의** : 중첩 질의는 다른 질의의 WHERE 절에 포함된 SELECT 문이다.
* **GROUP BY절** : 질의 결과에서 GROUP BY 다음에 명시된 애트리뷰트에 동일한 값을 갖는 투플들을 한 그룹으로 묶는다.
* **HAVING 절** : HAVING 절은 투플들의 그룹이 만족해야 하는 조건을 나타낸다.
* **ORDER BY 절** : ORDER BY 절은 결과 투플들의 정렬 순서를 지정한다.



***SQL문이 실행되는 과정***

1. 투플들을 구하고
2. 조건들을 만족하는 투플들을 식별하고
3. 그롭들을 구하고
4. HAVING을 적용하여 일부 그룹들을 제거하고
5. 집단 함수의 값을 구하고
6. 결과 투플들을 정렬하여 사용자에게 제시한다



* **별칭(alias)**

  * 서로 다른 릴레이션에 동일한 이름을 가진 애트리뷰트가 속해 있을 때 애트리뷰트의 이름을 구분하는 한 가지 방법은 애트리뷰트 이름 앞에 릴레이션의 이름을 붙인다.

    ```sql
    EMPLOYEE.DNO	
    ---
    FROM EMPLOYEE AS E, DEPARTMENT AS D
    ```

* **릴레이션의 모든 애트리뷰트나 일부 애트리뷰트들을 검색**

  * *을 사용하면 릴레이션에 속하는 모든 애트리뷰트들을 검색한다.

    ```sql
    SELECT *
    FROM DEPARTMENT;	
    ```

* **문자열 비교**

  * LIKE 비교 연산자는 문자열의 일부에 대하여 비교 조건을 명시한다.

    ```sql
    LIKE 'S%'   // S로 시작하는 모든 문자열
    LIKE 'J___' // J 뒤에 4글자가 오는 문자열
    LIKE '%DB%'
    LIKE '_DB%'
    ```

    LIKE의 부정은 **NOT LIKE**이다. 그리고 대소문자 구분이 표준이지만 자동으로 해주는 DBMS도 많다. 

* **부정 연산자**

  * <> 가 C에서 != 과 같은 역할이다.

* **범위를 사용한 검색**

  * ```sql
    WHERE SALARY BETWEEN A AND B;
    ```

* **리스트를 사용한 검색**

  * IN은 리스트 내의 값과 비교한다. IN의 부정은 NOT IN이다.

    ```sql
    WHERE DNO IN (1,2,3)	
    ==
    WHERE DNO = 1 OR DNO = 2 OR DNO = 3
    ```

* **산술 연산자**

  * +-*/ 사용 가능

* **집단 함수**

  * 집단 함수는 SELECT 절과 HAVING 절에만 나타날 수 있다. HAVING절은 투플들의 그룹에 적용되기 때문에 집단 함수를 HAVING 절에 명시할 수 있다.
  * WHERE절은 각 투플에 적용되고, 투플들의 그룹에는 적용되지 않기 때문에 WHERE 절에는 집단 함수를 사용할 수는 없다.
  * COUNT, MIN, MAX는 숫자형 애트리뷰트와 비 숫자형 모두 적용가능하다.
  * SUM, AVG는 숫자형만 가능하다
  * COUNT(*)를 제외하고는 모든 집단 함수들이 널값을 제거한 후 남아 있는 값에 대해서 값을 구한다.
  * COUNT(애트리뷰트)는 널값을 제외한 갯수를 센다.

* **HAVING** 

  * HAVING 절은 그룹화 애트리뷰트에 같은 값을 갖는 투플들의 그룹에 대한 조건을 나타내고, 이 조건을 만족하는 그룹들만 질의 결과에 나타난다.
  * WHERE 절과 비슷하지만 WHERE 절은 투플들을 걸러내고, HAVING은 그룹들을 걸러낸다는 점이 다르다

* **집합 연산**

  * 집합 연산을 적용하려면 두 릴레이션이 합집합 호환성을 가져야 한다.
  * 첫 번째 질의의 애트리뷰트 이름들이 결과에 나타난다.
  * UNION ALL을 제외하고 결과가 오름차순으로 정렬된다. 그리고 모든 집합 연산의 결과 릴레이션에서 중복된 투플들이 자동적으로 삭제된다.