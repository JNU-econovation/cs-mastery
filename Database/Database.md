# Database

### 목차

* [1장 데이터베이스 시스템](#1.-데이터베이스-시스템)
  * [데이터베이스의 특징](#데이터베이스의-특징)
  * [1.1 데이터베이스 시스템 개요](#1.1-데이터베이스-시스템-개요)
    * [1.1.1 데이터베이스 스키마와 상태](#1.1.1-데이터베이스-스키마와-상태)
    * [1.1.2 데이터베이스 시스템의 구성요소](#1.1.2-데이터베이스-시스템의-구성요소)
    * [1.1.3 데이터베이스 시스템의 요구사항](#1.1.3-데이터베이스-시스템의-요구사항)
  * [파일 시스템 방식과 DBMS 방식의 비교](#파일-시스템-방식과-dbms-방식의-비교)
  * [1.2 DBMS 언어](1.2-dbms-언어)
  * [1.3 DBMS 사용자](#1.3-dbms-사용자)
  * [1.4 데이터베이스 시스템 아키텍쳐](#1.4-데이터베이스-시스템-아키텍쳐)
    * [클라이언트 - 서버 데이터베이스 시스템](#클라이언트---서버-데이터베이스-시스템)

---

## 1. 데이터베이스 시스템

> 데이터베이스는 조직체의 응용 시스템들이 공유해서 사용하는 운영 데이터들이 구조적으로 통합된 모임이다.

### 데이터베이스의 특징

* 데이터베이스는 데이터의 대규모 저장소로서, 여러 부서에 속하는 여러 사용자에 의해 동시에 사용된다. 더 이상 데이터를 한 사용자 또는 한 부서에서 소유하지 않는다. 데이터베이스는 이제 조직체의 모든 구성원이 공유하는 자원이다
* 중복된 데이터를 갖는 별도의 파일들로 유지되는 대신에 데이터베이스에서는 모든 데이터가 중복을 최소화하면서 통합된다.
* 데이터베이스는 한 조직체의 운영 데이터뿐만 아니라 그 데이터에 관한 설명까지 포함한다. 이런 설명을 데이터베이스 스키마 또는 메타데이터라고 한다. 메타데이터는 데이터에 관한 데이터라는 뜻이다.
* 데이터의 구조가 프로그램과 분리되어 데이터베이스에 저장되므로 프로그램과 데이터 간의 독립성이 제공된다.
* 데이터베이스는 효육적으로 접근이 가능하고 질의를 할 수 있다.

### 1.1 데이터베이스 시스템 개요

#### 1.1.1 데이터베이스 스키마와 상태

* **데이터베이스 스키마** : 전체적인 데이터베이스 구조를 뜻하며 자주 변경되지 않는다. 데이터베이스의 모든 가능한 상태를 미리 정의한다. 내포(intension)이라고 부르기도 한다.
* **데이터베이스 상태** : 특정 시점의 데이터베이스의 내용을 의미하며, 시간이 지남에 따라 계속해서 바뀐다. 데이터베이스 상태를 외연(extension)이라고 부르기도 한다.

#### 1.1.2 데이터베이스 시스템의 구성요소

> 데이터베이스 시스템(DBS : Database System)은 데이터베이스, 사용자(응용 프로그램), DBMS, 하드웨어로 구성된다. 

![default](https://user-images.githubusercontent.com/14870706/47412953-fda8ab80-d7a7-11e8-8cd5-524a394fb653.jpeg)

* **데이터베이스** : 데이터베이스는 조직체의 응용 시스템들이 공유해서 사용하는 운영 데이터들이 구조적으로 통합된 모임이다.
* **시스템 카탈로그** : 저장된 데이터베이스의 스키마 정보를 유지한다. 사용자가 새로운 테이블을 만들거나 기존의 테이블에 새로운 애트리뷰트를 추가하는 작업 등을 수행하면 시스템 카탈로그에 이를 반영하는 스키마 정보가 삽입된다.
* **DBMS** : 실세계는 동적이기 때문에 계속해서 엔티티가 생성, 수정, 삭제된다. 적은 수라면 수작업으로 관리 가능하지만, 수십개 이상의 엔티티가 연관되고 비즈니스의 규모가 매우 크다면 비즈니스의 상태를 유지하는 것이 더 이상 수작업으로는 불가능해진다. 그래서 DBMS는 사용자가 새로운 데이터베이스를 생성하고 데이터베이스 구조를 명시할 수 있게 하고, 사용자가 데이터를 효율적으로 질의하고 수정할 수 있도록 하며, 시스템의 고장이나 권한이 없는 사용자로부터 데이터를 안전하게 보호하며, 동시에 여러 사용자가 데이터베이스를 접근하는 것을 제어하는 소프트웨어 패키지이다.
* **SQL** : 여러 DBMS에서 제공되는 사실상의 표준 데이터베이스 언어이다.
* **하드웨어** : 데이터베이스는 디스크와 같은 보조 기억 장치에 저장되며, DBMS에서 원하는 정보를 찾기 위해서는 디스크의 블록들을 주기억 장치로 읽어들여야 한다. 또한 계산이나 비교 연산들을 수행하기 위해 중앙 처리 장치가 사용된다. DBMS 자체도 주기억 장치에 적재되어 실행되어야 하므로 하드웨어 자원들을 필요로 한다.

#### 1.1.3 데이터베이스 시스템의 요구사항

* **데이터의 독립성** : 응용 프로그램이 데이터 표현의 상세한 내역과 데이터 저장으로부터 독립적이다 (파일 시스템과는 반대)
* **융통성** : 기존의 응용 프로그램에 영향을 주지 않으면서 데이터베이스 구조를 변경할 수 있어야한다.
* **효율적인 데이터 접근** : 방대한 데이터베이스를 효율적으로 저장하고 접근하기 위해서 다수의 정교한 기법을 제공해야한다. 일반적으로 인덱스 구조가 이런 목적으로 사용된다.
* **데이터에 대한 동시 접근** : 여러 사용자가 동일한 데이터베이스를 동시에 접근하는 경우가 많다. 각 사용자가 혼자서 데이터베이스를 접근하는 것처럼 인식하도록 데이터베이스에 대한 동시 접근을 동기화하기 위한 동시성 제어를 제공해야 한다.
* **백업과 회복** : 시스템 에러 등으로부터 데이터베이스를 회복하며, 디스크 등이 손상을 입는 경우를 대비해서 백업을 수행한다.
* **중복을 줄이거나 제어하여 일관성 유지** : 데이터를 통합함으로써 동일한 데이터가 여러 개의 사본으로 존재하는 것을 피한다. 성능을 향상시키기 위해 중복을 일부 허용하고 제어할 수 있다.
* **데이터 무결성** : 데이터 무결성은 의미적인 측면에서 데이터가 정확하고 완전함을 의미한다. 사용자가 무결성 제약조건을 정의하면 DBMS는 데이터를 삽입, 삭제, 수정할 때 마다 제약조건을 자동적으로 검사한다. 
* **데이터 보안** : 권한이 없는 접근으로부터 데이터베이스를 보호한다.
* **쉬운 질의어**
* **다양한 사용자 인터페이스의 제공**

*파일 시스템은 이 모든 것들의 반대이다.*

### 파일 시스템 방식과 DBMS 방식의 비교

|                       파일 시스템 방식                       |                          DBMS 방식                           |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|             데이터에 대한 물리적 접근만 조정한다             |  데이터에 대한 물리적 접근과 논리적인 접근을 모두 조정한다.  |
| 동일한 파일을 두 개 이상의 프로그램이 동시에 접근할 수 없다. |     동일한 데이터를 다수 사용자가 동시에 접근할 수 있다      |
|    데이터가 비구조적이며, 중복성과 유지보수 비용이 높다.     |  데이터가 구조화되어 있으며, 중복성과 유지보수 비용이 낮다.  |
| 어떤 프로그램이 기록한 데이터는 다른 프로그램에서 읽을 수 없는 경우가 많다. |     접근 권한이 있는 모든 프로그램이 데이터를 공유한다.      |
| 데이터에 대한 접근은 미리 작성된 프로그램을 통해서만 가능하다. | 질의어를 사용하여 데이터에 대한 융통성 있는 접근이 가능하다. |
| 각 응용 프로그램마다 파일이 따로 있으므로 데이터가 통합되어 있지 않다. |          데이터가 중복을 배제하면서 통합되어 있다.           |

---

### 1.2 DBMS 언어

* **데이터 정의어(DDL : Data Definition Language)** : 사용자는 데이터 정의어를 사용하여 데이터베이스 스키마를 정의한다. DBMS는 사용자가 정의한 스키마에 대한 명세를 시스템 카탈로그 또는 데이터 사전에 저장한다. 시스템 카탈로그는 메타데이터를 저장한다. 메타데이터는 데이터베이스에 저장된 데이터에 관한 데이터를 말한다. 
  * EX > CREATE, ALTER, DROP
* **데이터 조작어(DML : Data Manipulation Language)** : 사용자는 데이터 조작어를 사용하여 데이터베이스 내의 원하는 데이터를 검색하고 수정하고 삽입하고 삭제한다. 그리고 대부분의 데이터 조작어에는 SUM, COUNT, AVG와 같은 내장 함수들이 있는데, 이것들은 C, COBOL과 같은 호스트 언어들을 사용하여 제작된 프로그램에 내포되어 사용된다. 그 이유는 데이터 조작어에는 조건문, 반복문, 입력문 등이 없기 때문이다
  * EX > SELECT, UPDATE, DELETE, INSERT
* **데이터 제어어(DCL : Data Control Language)** : 사용자는 데이터 제어어를 사용하여 데이터베이스 트랜잭션을 명시하고 권한을 부여하거나 취소한다. 해당 개념은 후에 트랜잭션을 다루면서 추가적으로 설명하겠다.

---

### 1.3 DBMS 사용자

* **데이터베이스 관리자 (DBA : Database Administrator)** : 조직의 여러 부분의 상이한 요구를 만족시키기 위해서 일관성 있는 데이터베이스 스키마를 생성하고 유지하는 사람을 말한다. 하는 일은 다음과 같다.
  * 데이터베이스 스키마의 생성과 변경
  * 한꺼번에 적재(bulk loading)
  * 무결성 제약조건을 명시
  * 사용자의 권한을 허용하거나 취소하고, 사용자의 역할을 관리
  * 저장 구조와 접근 방법(물리적 스키마) 정의
  * 백업과 회복
  * 표준화 시행
* **응용 프로그래머** : 데이터베이스 위에서 특정 응용 프로그램이나 인터페이스를 구현하는 사람으로서 `DML`의 주요 사용자다. 이들이 작성한 프로그램은 최종 사용자들이 반복해서 수행하므로 **'기작성 트랜잭션(Canned Transaction)'**이라고 부른다.
* **End User(최종 사용자)** : 최종 사용자는 질의하거나 갱신하거나 보고서를 생성하기 위해서 데이터베이스를 사용하는 사람으로서 데이터 정의어나 데이터 조작어를 직접 사용하는 경우는 비교적 많지 않다.
* **데이터베이스 설계자** : ERWin, CASE 도구들을 이용해서 데이터베이스 설계를 책임진다. 데이터베이스의 일관성을 유지하기 위해서 정규화를 수행한다. 데이터베이스를 효율적으로 접근할 수 있도록 인덱스 등을 정의한다. 설계에 관한 문서화 작업도 한다

---

### 1.4 데이터베이스 시스템 아키텍쳐

![ë°ì´í°ë² ì´ì¤ ìì¤í ìí¤íì²ì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](https://t1.daumcdn.net/cfile/tistory/2434CC5055F2A8942E)

* 데이터베이스 관리자가 **데이터 정의어**를 사용하여 테이블 생성을 요청
* **데이터 정의어 컴파일러**가 이를 번역하여 테이블이 파일 형태로 데이터베이스에 만들어진다
* 이 테이블에 대한 명세가 **시스템 카탈로그에 저장**된다.
* 최종 사용자나 응용 프로그래머가 데이터 조작어를 사용하여 데이터베이스를 접근하려 하면 DBMS의 **질의 처리기**를 통해서 기계어 코드로 번역된다.
* DBMS의 **런타임 데이터베이스 관리기**에 의해 데이터베이스가 접근된다.
* 이 과정에서 사용자가 원하는 테이블이 데이터베이스에 존재하는가, 데이터 조작어를 입력한 사용자가 해당 테이블을 접근할 수 잇는 권한이 있는가, 테이블에 어떤 접근 경로들이 존재하는가 등을 **시스템 카탈로그를 접근하여 확인**한다.
* 여러 사용자가 공용 데이터베이스를 접근할 때 생길 수 있는 데이터 불일치를 해결하기 위해서 **동시성 제어 모듈이 사용**된다.
* 데이터베이스를 접근하는 도중에 시스템이 다운되면, 다운되기 직전의 일관된 데이터베이스 상태를 복구하기 위해서 **회복 모듈**이 사용된다.
* 동시성 제어 모듈과 회복 모듈을 합쳐서 **트랜잭션 관리 모듈**이라 부른다.

#### 클라이언트 - 서버 데이터베이스 시스템

> 클라이언트-서버 아키텍처는 클라이언트와 데이터베이스 서버가 직접 연결되는 **2-tier Model**과, 클라이언트와 데이터베이스 서버 사이에 **응용 서버**(Application Server)가 추가된 **3-tier Model**로 구분한다.

* **2-Tier Model** : 어플리케이션의 논리(DB관련 로직)가 클라이언트와 서버에 흩어져 있다.
* **3-Tier Model** : 어플리케이션의 논리가 어플리케이션 서버에만 포함되어 있다. 서비스 요청과 응답이 클라이언트와 어플리케이션 서버 간에만 전송되기 때문에 성능이 향상된다. 또한 응용 소프트웨어를 다수의 클라이언트 대신에 소수의 어플리케이션 서버에 설치하게 되므로 구현 및 유지보수가 용이하다.

클라이언트-서버 데이터베이스 시스템의 장점은 기존의 데이터베이스를 보다 넓은 지역에서 접근할 수 있고, 성능이 향상되며, 하드웨어 비용이 절감된다는 것이다. 또한 다양한 컴퓨터 시스템을 사용할 수 있다. 예를 들어, 클라이언트는 PC에서 윈도우 운영 체제를 사용하고, 서버는 워크스테이션이나 메인프레임에서 UNIX 운영 체제를 사용할 수 있다. 보안이 다소 취약할 수 잇따는 것은 클라이언트-서버 데이터베이스 시스템의 단점이다.
