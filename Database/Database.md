# Database

### 목차

* [1장 데이터베이스 시스템](#1.-데이터베이스-시스템)
  * [데이터베이스의 특징](#데이터베이스의-특징)
  * [데이터베이스 시스템 개요](#데이터베이스-시스템-개요)
    * [데이터베이스 스키마와 상태](#데이터베이스-스키마와-상태)
    * [데이터베이스 시스템의 구성요소](#데이터베이스-시스템의-구성요소)
    * [데이터베이스 시스템의 요구사항](#데이터베이스-시스템의-요구사항)
  * [파일 시스템 방식과 DBMS 방식의 비교](#파일-시스템-방식과-dbms-방식의-비교)
  * [DBMS 언어](#dbms-언어)
  * [DBMS 사용자](#dbms-사용자)
  * [데이터베이스 시스템 아키텍쳐](#데이터베이스-시스템-아키텍쳐)
    * [클라이언트 서버 데이터베이스 시스템](#클라이언트-서버-데이터베이스-시스템)
* [2장 관계 데이터 모델과 제약조건](#2장-관계-데이터-모델과-제약조건)
  * [기본적인 용어](#기본적인-용어)
  * [스키마와 인스턴스](#스키마와-인스턴스)
  * [릴레이션의 특성](#릴레이션의-특성)
  * [릴레이션의 키](#릴레이션의-키)
  * [무결성 제약조건](#무결성-제약조건)
  * [무결성 제약조건의 유지](#무결성-제약조건의-유지)

---

## 1. 데이터베이스 시스템

> 데이터베이스는 조직체의 응용 시스템들이 공유해서 사용하는 운영 데이터들이 구조적으로 통합된 모임이다.

### 데이터베이스의 특징

* 데이터베이스는 데이터의 대규모 저장소로서, 여러 부서에 속하는 여러 사용자에 의해 동시에 사용된다. 더 이상 데이터를 한 사용자 또는 한 부서에서 소유하지 않는다. 데이터베이스는 이제 조직체의 모든 구성원이 공유하는 자원이다
* 중복된 데이터를 갖는 별도의 파일들로 유지되는 대신에 데이터베이스에서는 모든 데이터가 중복을 최소화하면서 통합된다.
* 데이터베이스는 한 조직체의 운영 데이터뿐만 아니라 그 데이터에 관한 설명까지 포함한다. 이런 설명을 데이터베이스 스키마 또는 메타데이터라고 한다. 메타데이터는 데이터에 관한 데이터라는 뜻이다.
* 데이터의 구조가 프로그램과 분리되어 데이터베이스에 저장되므로 프로그램과 데이터 간의 독립성이 제공된다.
* 데이터베이스는 효육적으로 접근이 가능하고 질의를 할 수 있다.

### 데이터베이스 시스템 개요

#### 데이터베이스 스키마와 상태

* **데이터베이스 스키마** : 전체적인 데이터베이스 구조를 뜻하며 자주 변경되지 않는다. 데이터베이스의 모든 가능한 상태를 미리 정의한다. 내포(intension)이라고 부르기도 한다.
* **데이터베이스 상태** : 특정 시점의 데이터베이스의 내용을 의미하며, 시간이 지남에 따라 계속해서 바뀐다. 데이터베이스 상태를 외연(extension)이라고 부르기도 한다.

#### 데이터베이스 시스템의 구성요소

> 데이터베이스 시스템(DBS : Database System)은 데이터베이스, 사용자(응용 프로그램), DBMS, 하드웨어로 구성된다. 

![default](https://user-images.githubusercontent.com/14870706/47412953-fda8ab80-d7a7-11e8-8cd5-524a394fb653.jpeg)

* **데이터베이스** : 데이터베이스는 조직체의 응용 시스템들이 공유해서 사용하는 운영 데이터들이 구조적으로 통합된 모임이다.
* **시스템 카탈로그** : 저장된 데이터베이스의 스키마 정보를 유지한다. 사용자가 새로운 테이블을 만들거나 기존의 테이블에 새로운 애트리뷰트를 추가하는 작업 등을 수행하면 시스템 카탈로그에 이를 반영하는 스키마 정보가 삽입된다.
* **DBMS** : 실세계는 동적이기 때문에 계속해서 엔티티가 생성, 수정, 삭제된다. 적은 수라면 수작업으로 관리 가능하지만, 수십개 이상의 엔티티가 연관되고 비즈니스의 규모가 매우 크다면 비즈니스의 상태를 유지하는 것이 더 이상 수작업으로는 불가능해진다. 그래서 DBMS는 사용자가 새로운 데이터베이스를 생성하고 데이터베이스 구조를 명시할 수 있게 하고, 사용자가 데이터를 효율적으로 질의하고 수정할 수 있도록 하며, 시스템의 고장이나 권한이 없는 사용자로부터 데이터를 안전하게 보호하며, 동시에 여러 사용자가 데이터베이스를 접근하는 것을 제어하는 소프트웨어 패키지이다.
* **SQL** : 여러 DBMS에서 제공되는 사실상의 표준 데이터베이스 언어이다.
* **하드웨어** : 데이터베이스는 디스크와 같은 보조 기억 장치에 저장되며, DBMS에서 원하는 정보를 찾기 위해서는 디스크의 블록들을 주기억 장치로 읽어들여야 한다. 또한 계산이나 비교 연산들을 수행하기 위해 중앙 처리 장치가 사용된다. DBMS 자체도 주기억 장치에 적재되어 실행되어야 하므로 하드웨어 자원들을 필요로 한다.

#### 데이터베이스 시스템의 요구사항

* **데이터의 독립성** : 응용 프로그램이 데이터 표현의 상세한 내역과 데이터 저장으로부터 독립적이다 (파일 시스템과는 반대)
* **융통성** : 기존의 응용 프로그램에 영향을 주지 않으면서 데이터베이스 구조를 변경할 수 있어야한다.
* **효율적인 데이터 접근** : 방대한 데이터베이스를 효율적으로 저장하고 접근하기 위해서 다수의 정교한 기법을 제공해야한다. 일반적으로 인덱스 구조가 이런 목적으로 사용된다.
* **데이터에 대한 동시 접근** : 여러 사용자가 동일한 데이터베이스를 동시에 접근하는 경우가 많다. 각 사용자가 혼자서 데이터베이스를 접근하는 것처럼 인식하도록 데이터베이스에 대한 동시 접근을 동기화하기 위한 동시성 제어를 제공해야 한다.
* **백업과 회복** : 시스템 에러 등으로부터 데이터베이스를 회복하며, 디스크 등이 손상을 입는 경우를 대비해서 백업을 수행한다.
* **중복을 줄이거나 제어하여 일관성 유지** : 데이터를 통합함으로써 동일한 데이터가 여러 개의 사본으로 존재하는 것을 피한다. 성능을 향상시키기 위해 중복을 일부 허용하고 제어할 수 있다.
* **데이터 무결성** : 데이터 무결성은 의미적인 측면에서 데이터가 정확하고 완전함을 의미한다. 사용자가 무결성 제약조건을 정의하면 DBMS는 데이터를 삽입, 삭제, 수정할 때 마다 제약조건을 자동적으로 검사한다. 
* **데이터 보안** : 권한이 없는 접근으로부터 데이터베이스를 보호한다.
* **쉬운 질의어**
* **다양한 사용자 인터페이스의 제공**

*파일 시스템은 이 모든 것들의 반대이다.*

### 파일 시스템 방식과 DBMS 방식의 비교

|                       파일 시스템 방식                       |                          DBMS 방식                           |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|             데이터에 대한 물리적 접근만 조정한다             |  데이터에 대한 물리적 접근과 논리적인 접근을 모두 조정한다.  |
| 동일한 파일을 두 개 이상의 프로그램이 동시에 접근할 수 없다. |     동일한 데이터를 다수 사용자가 동시에 접근할 수 있다      |
|    데이터가 비구조적이며, 중복성과 유지보수 비용이 높다.     |  데이터가 구조화되어 있으며, 중복성과 유지보수 비용이 낮다.  |
| 어떤 프로그램이 기록한 데이터는 다른 프로그램에서 읽을 수 없는 경우가 많다. |     접근 권한이 있는 모든 프로그램이 데이터를 공유한다.      |
| 데이터에 대한 접근은 미리 작성된 프로그램을 통해서만 가능하다. | 질의어를 사용하여 데이터에 대한 융통성 있는 접근이 가능하다. |
| 각 응용 프로그램마다 파일이 따로 있으므로 데이터가 통합되어 있지 않다. |          데이터가 중복을 배제하면서 통합되어 있다.           |

---

### DBMS 언어

* **데이터 정의어(DDL : Data Definition Language)** : 사용자는 데이터 정의어를 사용하여 데이터베이스 스키마를 정의한다. DBMS는 사용자가 정의한 스키마에 대한 명세를 시스템 카탈로그 또는 데이터 사전에 저장한다. 시스템 카탈로그는 메타데이터를 저장한다. 메타데이터는 데이터베이스에 저장된 데이터에 관한 데이터를 말한다. 
  * EX > CREATE, ALTER, DROP
* **데이터 조작어(DML : Data Manipulation Language)** : 사용자는 데이터 조작어를 사용하여 데이터베이스 내의 원하는 데이터를 검색하고 수정하고 삽입하고 삭제한다. 그리고 대부분의 데이터 조작어에는 SUM, COUNT, AVG와 같은 내장 함수들이 있는데, 이것들은 C, COBOL과 같은 호스트 언어들을 사용하여 제작된 프로그램에 내포되어 사용된다. 그 이유는 데이터 조작어에는 조건문, 반복문, 입력문 등이 없기 때문이다
  * EX > SELECT, UPDATE, DELETE, INSERT
* **데이터 제어어(DCL : Data Control Language)** : 사용자는 데이터 제어어를 사용하여 데이터베이스 트랜잭션을 명시하고 권한을 부여하거나 취소한다. 해당 개념은 후에 트랜잭션을 다루면서 추가적으로 설명하겠다.

---

### DBMS 사용자

* **데이터베이스 관리자 (DBA : Database Administrator)** : 조직의 여러 부분의 상이한 요구를 만족시키기 위해서 일관성 있는 데이터베이스 스키마를 생성하고 유지하는 사람을 말한다. 하는 일은 다음과 같다.
  * 데이터베이스 스키마의 생성과 변경
  * 한꺼번에 적재(bulk loading)
  * 무결성 제약조건을 명시
  * 사용자의 권한을 허용하거나 취소하고, 사용자의 역할을 관리
  * 저장 구조와 접근 방법(물리적 스키마) 정의
  * 백업과 회복
  * 표준화 시행
* **응용 프로그래머** : 데이터베이스 위에서 특정 응용 프로그램이나 인터페이스를 구현하는 사람으로서 `DML`의 주요 사용자다. 이들이 작성한 프로그램은 최종 사용자들이 반복해서 수행하므로 **'기작성 트랜잭션(Canned Transaction)'**이라고 부른다.
* **End User(최종 사용자)** : 최종 사용자는 질의하거나 갱신하거나 보고서를 생성하기 위해서 데이터베이스를 사용하는 사람으로서 데이터 정의어나 데이터 조작어를 직접 사용하는 경우는 비교적 많지 않다.
* **데이터베이스 설계자** : ERWin, CASE 도구들을 이용해서 데이터베이스 설계를 책임진다. 데이터베이스의 일관성을 유지하기 위해서 정규화를 수행한다. 데이터베이스를 효율적으로 접근할 수 있도록 인덱스 등을 정의한다. 설계에 관한 문서화 작업도 한다

---

### 데이터베이스 시스템 아키텍쳐

![ë°ì´í°ë² ì´ì¤ ìì¤í ìí¤íì²ì ëí ì´ë¯¸ì§ ê²ìê²°ê³¼](https://t1.daumcdn.net/cfile/tistory/2434CC5055F2A8942E)

* 데이터베이스 관리자가 **데이터 정의어**를 사용하여 테이블 생성을 요청
* **데이터 정의어 컴파일러**가 이를 번역하여 테이블이 파일 형태로 데이터베이스에 만들어진다
* 이 테이블에 대한 명세가 **시스템 카탈로그에 저장**된다.
* 최종 사용자나 응용 프로그래머가 데이터 조작어를 사용하여 데이터베이스를 접근하려 하면 DBMS의 **질의 처리기**를 통해서 기계어 코드로 번역된다.
* DBMS의 **런타임 데이터베이스 관리기**에 의해 데이터베이스가 접근된다.
* 이 과정에서 사용자가 원하는 테이블이 데이터베이스에 존재하는가, 데이터 조작어를 입력한 사용자가 해당 테이블을 접근할 수 잇는 권한이 있는가, 테이블에 어떤 접근 경로들이 존재하는가 등을 **시스템 카탈로그를 접근하여 확인**한다.
* 여러 사용자가 공용 데이터베이스를 접근할 때 생길 수 있는 데이터 불일치를 해결하기 위해서 **동시성 제어 모듈이 사용**된다.
* 데이터베이스를 접근하는 도중에 시스템이 다운되면, 다운되기 직전의 일관된 데이터베이스 상태를 복구하기 위해서 **회복 모듈**이 사용된다.
* 동시성 제어 모듈과 회복 모듈을 합쳐서 **트랜잭션 관리 모듈**이라 부른다.

#### 클라이언트 서버 데이터베이스 시스템

> 클라이언트-서버 아키텍처는 클라이언트와 데이터베이스 서버가 직접 연결되는 **2-tier Model**과, 클라이언트와 데이터베이스 서버 사이에 **응용 서버**(Application Server)가 추가된 **3-tier Model**로 구분한다.

* **2-Tier Model** : 어플리케이션의 논리(DB관련 로직)가 클라이언트와 서버에 흩어져 있다.
* **3-Tier Model** : 어플리케이션의 논리가 어플리케이션 서버에만 포함되어 있다. 서비스 요청과 응답이 클라이언트와 어플리케이션 서버 간에만 전송되기 때문에 성능이 향상된다. 또한 응용 소프트웨어를 다수의 클라이언트 대신에 소수의 어플리케이션 서버에 설치하게 되므로 구현 및 유지보수가 용이하다.

클라이언트-서버 데이터베이스 시스템의 장점은 기존의 데이터베이스를 보다 넓은 지역에서 접근할 수 있고, 성능이 향상되며, 하드웨어 비용이 절감된다는 것이다. 또한 다양한 컴퓨터 시스템을 사용할 수 있다. 예를 들어, 클라이언트는 PC에서 윈도우 운영 체제를 사용하고, 서버는 워크스테이션이나 메인프레임에서 UNIX 운영 체제를 사용할 수 있다. 보안이 다소 취약할 수 잇따는 것은 클라이언트-서버 데이터베이스 시스템의 단점이다.



---

## 2장 관계 데이터 모델과 제약조건

### 기본적인 용어

* **릴레이션** : 2차원 테이블을 의미한다. 이 모델에서 정보는 **행(=투플=레코드), 열(=애트리뷰트)**로 표현된다.

* **카디날리티** : 행들의 수

* **차수(Degree)** : 열들의 수

* **도메인** : 한 애트리뷰트에 나타날 수 있는 값들의 집합이다. (원자값)

  * CREATE DOMAIN EMPNO INTEGER

  * CREATE DOMAIN EMPNO2 INTEGER

    둘다 정수형이지만 서로 의미가 다른 도메인이므로 비교 연산이 불가능해진다. 의미 있는 연산들만 허용하기 위해 사용된다.


### 스키마와 인스턴스

> 스키마는 릴레이션을 위한 틀이다. 릴레이션 스키마는 아래와 같은 표기법을 사용하여 나타낸다.

* 릴레이션이름(<u>애트리뷰트1</u> … 애트리뷰트N) - 밑줄 친 부분은 Primary Key이다.

> 릴레이션 인스턴스는 릴레이션에 어느 시점에 들어 있는 투플들의 집합니다.

* 릴레이션 인스턴스는 정적이지 않고 시간의 흐름에 따라 계속 변한다.


### 릴레이션의 특성

* 각 릴레이션은 오직 하나의 레코드 타입만 포함한다.

* 한 애트리뷰트 내의 값들은 모두 같은 유형이다.

* 애트리뷰트들의 순서는 중요하지 않다. (순서가 달라도 같다)

  * 관계 모델에서 애트리뷰트 값은 릴레이션 내에서의 애트리뷰트의 위치에 의해서가 아니고 애트리뷰트의 이름에 의해서 참조된다.

* 릴레이션이 투플들의 집합이기 때문에 동일한 투플이 두 개 이상 존재하지 않는다. 

  * 한 릴레이션에 동일한 두 투플이 두 개 이상 존재하지 않는다는 특성을 시행하려면 DBMS의 오버헤드가 증가하기 때문에 상용 관계 DBMS에서는 사용자가 명시하지 않는 한 일반적으로 이 특성을 시행하지 않는다. 즉 상용 관계 DBMS가 관리하는 테이블에는 중복된 투플들이 존재할 수 있다.

* 한 투플의 각 애트리뷰트는 원자값을 갖는다.

  | DEPTNO | DEPTNAME | FLOOR            |
  | ------ | -------- | ---------------- |
  | 1      | 영업     | {8 , 9} - 불가능 |
  | 2      | 기획     | 10               |
  | 3      | 개발     | {7, 9} - 불가능  |

* 릴레이션이 투플들의 집합이기 때문에 투플들의 순서는 중요하지 않다.

* 각 애트리뷰트의 이름은 한 릴레이션 내에서만 고유하다



### 릴레이션의 키

* **수퍼 키** : 수퍼 키는 한 릴레이션 내의 특정 투플을 고유하게 식별하는 하나의 애트리뷰트 또는 애트리뷰트들의 집합이다.
  * `(신용카드번호, 주소)` 또는 `(주민등록번호, 이름)` 모두 수퍼 키가 될 수 있다. 
  * 신용카드번호나 주민번호를 포함하는 어떠한 집합도 수퍼 키 이다.
  * **문제점** : 투플들을 고유하게 식별하는데 꼭 필요하지 않은 애트리뷰트들을 포함할 수 있다는 것
* **후보 키** : 후보 키는 각 투플을 고유하게 식별하는 최소한의 애트리뷰트들의 모임이다. 즉 후보 키를 구성하는 애트리뷰트들 중에서 어느 한 애트리뷰트라도 빼면 고유하게 식별하는 능력을 상실한다.
  * `(신용카드번호, 주소)`는 신용카드 회사의 고객 릴레이션의 후보 키가 아니지만 `(신용카드번호)`는 후보 키다.
  * 후보 키도 두개 이상의 애트리뷰트로 이루어질 수 있으며 이런 경우에 **복합 키(composite key)**라고 부른다.
* **기본 키(primary key)** : 한 릴레이션에 후보 키가 두 개 이상 있으면 데이터베이스 설계자 또는 데이터베이스 관리자가 이들 중에서 하나를 기본 키로 선정한다. 즉, 후보 키 중에 하나 골라서 기본 키로 명명하면 그게 기본 키가 되는 것이다.
  * 기본 키는 한 릴레이션 내의 모든 투플을 고유하게 식별할 수 있어야 하므로ㅜ 널값이나 중복된 값을 가질 수 없다. 한 릴레이션의 기본 키를 선정할 때 추가로 고려할 사항은 다음과 같다.
    * 애트리뷰트가 항상 고유한 값을 가질 것인가
    * 애트리뷰트가 확실하게 널값을 갖지 않을 것인가
    * 애트리뷰트의 값이 변경될 가능성이 높은 애트리뷰트는 기본 키로 선정하지 말 것
    * 가능하면 작은 정수 값이나 짧은 문자열을 갖는 애트리뷰트
    * 가능하면 복합 기본 키를 피할 것
* **대체 키** : 대체 키는 기본 키로 선정되지 않은 후보 키를 말한다. 신용카드 회사의 고객 릴레이션에서 신용카드번호를 기본 키로 선정하면 주민등록번호는 대체 키가 된다.

<u>지금까지 릴레이션 키들의 관계를 정리해보면,  수퍼키 > 후보키 > 기본키|대체키 로 표현할 수 있다.</u>

* **외래 키** : 외래 키는 어떤 릴레이션의 기본 키를 참조하는 애트리뷰트이다. 외래 키는 관계 데이터베이스에서 릴레이션들 간의 관계를 나타내기 위해서 사용된다. 외래 키의 유형을 몇 가지로 구분하여 살펴보겠다.

  * 다른 릴레이션의 기본 키를 참조하는 외래 키

    **EMPLOYEE 테이블**

    | <u>EMPNO</u> | EMPNAME | DNO (외래키) |
    | ------------ | ------- | ------------ |
    | 2104         | 김창섭  | 2            |
    | 1232         | 박영권  | 3            |
    | 1003         | 조민희  | 1            |

    **DEPARTMENT 테이블**

    | <u>DEPTNO</u> | DEPTNAME | FLOOR |
    | ------------- | -------- | ----- |
    | 1             | 영업     | 8     |
    | 2             | 기획     | 10    |
    | 3             | 개발     | 9     |

  * 자체 릴레이션의 기본 키를 참조하는 외래 키

    | EMPNO | EMPNAME | MANAGER(외래키) |
    | ----- | ------- | --------------- |
    | 2106  | 김창섭  | 3426            |
    | 3426  | 박영권  | 3011            |
    | 3011  | 이수민  | ^               |

  * 기본 키의 구성요소가 되는 외래 키

    * 학생(<u>학번</u>, 이름), 수강(<u>학번</u>, <u>과목번호</u>, 학점), 과목(<u>과목번호</u>, 과목이름) 이라는 테이블이 있다고 가정하자. 수강이라는 테이블의 기본키는 학번+과목번호이다. 그리고 학번은 학생 테이블의 학번을 참조하는 외래키이고, 과목번호는 과목이라는 테이블의 과목번호를 참조하는 외래키이다. 이것들이 모여 수강이라는 테이블에서 기본 키를 이루고 있다.



### 무결성 제약조건

> **무결성 제약조건은 다음과 같은 상황을 방지하기 위해서 필요하다.**

* 어떤 학생이 수강 신청을 했으나 학생들에 관한 정보를 포함하고 있는 릴레이션에 이 학생에 대한 데이터가 없다.
* 질의 처리 과정에 학생의 학번과 과목의 번호를 비교한다.
* 학생이 대학을 그만 두어서 학생 릴레이션에서는 이 학생에 대한 데이터가 삭제 되었으나 수강 릴레이션에는 여전히 남아 있다.

> **그렇다면 무결성 제약조건의 장점은?**

 : 스키마를 정의할 때 일관성 조건을 오직 한 번만 명시하고, 데이터베이스가 갱신될 때 DBMS가 자동적으로 일관성 조건을 검사하므로 응용 프로그램들은 일관성 조건을 검사할 필요가 없다는 것이다.



#### 도메인 제약조건

* 가장 간단한 형태의 제약조건
* 각 애트리뷰트 값이 반드시 원자값이어야 한다
* 데이터 형식을 통해 값들의 유형을 제한 한다.
* 애트리뷰트의 디폴트 값을 지정한다
* 애트리뷰트에 저장되는 값들의 범위를 제한할 수 있다.
* NOT NULL 구문을 통해 해당 애트리뷰트의 값이 존재하도록 보장한다.



#### 키 제약조건

* 키 애트리뷰트에 중복된 값이 존재해서는 안된다는 것이다
* UNIQUE나 기본키로 명시한 애트리뷰트에는 중복된 값이 허용되지 않는다.



#### 기본 키와 엔티티 무결성 제약조건

* 두 개 이상의 투플이 동일한 기본 키 값을 가질 수 없다.
* 릴레이션의 기본 키를 구성하는 어떤 애트리뷰트도 널값을 가질 수 없다



#### 외래 키와 참조 무결성 제약조건

* 두 엔티티 간의 관계도 관계 모델에서는 릴레이션으로 표현된다 (EX > 학생 - 수강(관계) - 과목)
* 두 릴레이션의 연관된 투플들 사이의 일관성을 유지하는데 사용되는 제약조건이다.
* 관계 데이터베이스가 포인터 없이 오직 릴레이션들로만 이루어지고, 릴레이션 사이의 관계들이 다른 릴레이션의 기본 키를 참조하는 것을 기반으로 하여 묵시적으로 표현되기 때문에 외래 키의 개념이 중요하다.
  * 외래 키의 값은 R1의 어떤 투플의 기본 키 값과 같다, 외래 키가 자신을 포함하고 있는 릴레이션의 기본 키를 구성하고 있지 않으면 널값을 가진다. 이 두 조건 중 하나가 성립되면 참조 무결성 제약조건을 만족한다.



### 무결성 제약조건의 유지

> DDL로 만들어진 현재 데이터베이스가 무결성 제약조건을 모두 만족한다고 하더라도, 갱신 연산(삽입, 수정, 삭제)이 일어나면 무결성이 파괴될 수 있다. DBMS는 외래 키가 갱신되거나, 참조된 기본 키가 갱신되었을 때 참조 무결성 제약조건이 위배되지 않도록 해야한다. DBMS가 갱신 연산을 거절하거나, 갱신을 전파하여 다른 갱신들이 자동적으로 수행되도록 하여야 한다.

* **삽입** 
  * 도메인 제약조건, 키 제약조건, 엔티티 무결성 제약조건 등은 위배할 수 있다.
    * EX > 똑같은 투플 삽입, 기본키 null 값 투플 삽입 등
  * 참조 무결성에서는 **참조하는 쪽**에서 무결성 위반이 일어날 수 있다
    *  EX > 없는 곳을 참조하기. 
    * **참조 당하는 쪽**에 삽입이 일어나면 참조 무결성을 해치는 경우는 발생하지 않는다.
* **삭제** 
  * 참조하는 릴레이션에서 투플이 삭제되면 모든 제약조건을 위배하지 않는다.
  * 참조되는 릴레이션에서 투플이 삭제되면 참조 무결성 제약 조건을 위배하는 경우가 생길 수도 있다.
    * EX > 해당 투플을 참조하고 있는 것이 있으면 무결성 제약 조건 위반
  * 참조 무결성 제약조건을 만족시키기 위해 DBMS는 몇 가지 옵션을 제공한다
    * **제한(restricted)** : 위배를 야기한 연산을 단순히 거절한다.
    * **연쇄(cascade)** : 참조되는 릴레이션에서 투플을 삭제하고, 참조하는 릴레이션에서 이 투플을 참조하는 투플들도 함께 삭제한다. (연관된 놈 다 죽이는 옵션)
    * **널 값** : 참조되는 릴레이션에서 투플을 삭제하고, 참조하는 릴레이션에서 이 투플을 참조하는 투플들의 애트리뷰트 값에 null 값을 넣어준다. (not null 일 경우 삭제 연산 거절)
    * **디폴트 값** : 널 값 대신에 디폴트 값을 넣는 옵션이다.
* **수정** 
  * 수정하는 애트리뷰트가 기본 키인지 외래 키인지 검사한다. (기본 키, 외래 키가 아니면 무결성 해칠 이유가 없으므로)
  * 기본 키, 외래 키에 해당한다면 하나의 투플을 삭제하고 새로운 투플을 그 자리에 삽입하는 것과 유사하므로 삽입과 삭제 규칙이 수정에도 고스란히 적용된다.

* **릴레이션** : 2차원의 테이블을 의미한다. 정보는 **행(=레코드=투플)**, **열(=애트리뷰트)**들로 표현된다.
* **카디날리티** : 행들의 수
* **Degree(차수)** : 열들의 수

* **도메인** : 한 애트리뷰트에 나타날 수 있는 값들의 집합 (원자값)
  * CREATE DOMAIN EMPNO INTEGER
  * CREATE DOMAIN DNO INTEGER
  * 서로 다른 도메인이므로 같은 INTEGER 값이어도 비교할 수 없게 된다.
* 

